\section{GT vs. Visitors}

Among existing generic programming frameworks for OCaml we can name two, which resemble ours: \cd{ppx\_deriving} and \cd{Visitors}~\cite{Visitors}.

\cd{Visitors}, on the other hand, explore a similar to ours object-oriented approach, in which many decisions, rejected by us, were taken (and vice versa). Here
we summarize the main differences:

\begin{itemize}
   \item \cd{Visitors} are excessively object-oriented~--- in order to use them one needs to instantiate some object and call a proper method. In our case as long as
     only predefined features are required a user can use a more native combinatorial interface.
     
   \item \cd{Visitors} implement a number of useful transformations in an \emph{ad-hoc} manner; in our case all transformations are instances of the
     same generic scheme. It is possible to combine different transformations via inheritance as long as the types of underlying scheme unify. We also argue, that
     in our framework the implementation of user-defined plugins is much easier.
     
   \item Following SYB, \cd{Visitors} take a type-discriminating route: for each type of interest (including the built-in ones) there is a dedicated
     transformation method in each object, representing a transformation. While this solution indeed adds some flexibility, we firmly oppose it, since it
     breaks the abstraction: inspecting the methods of a transformation (which cannot be hidden in a module signature) one can retrieve some
     information about the implementation of encapsulated types. Even worse, the data structures of abstract types can be manipulated in an unprescribed
     manner using the public type-transforming interface.
     \footnote{This paragraph is not fully obvious even for me. Kosarev}

   \item In our case the type parameters for transformation classes have to be specified by an end user. With \cd{Visitors} this burden is offloaded to the
     compiler with the aid of some neat trick. However, this trick makes it impossible to use \cd{Visitors} syntax extension in module signatures. There is no
     such problem in our case~--- our framework can be equally used in both implementation and interface files.

   \item \cd{Visitors} in their current state\footnote{The latest available version is 20180513} do not support polymorphic variants.
   
   \item GT supports arbitrary recursive types but \cd{Visitors} in their current state doesn't (both in monomorphic and polymorphic mode). For instance, the following example doesn't compile 
   \begin{lstlisting}
    type ('a,'b) alist = Nil | Cons of 'a * 'b
    [@@deriving visitors { variety = "map"; polymorphic = true }]

    type 'a list = ('a, 'a list) alist
    [@@deriving visitors { variety = "map"; polymorphic = false }]
    \end{lstlisting}
    Moreover, adding a ``fake'' construct doesn't solve a problem too.
    \begin{lstlisting}
    type 'a list = L of ('a, 'a list) alist [@@unboxed]
    [@@deriving visitors { variety = "map"; polymorphic = false }]
    \end{lstlisting}
    There are also issue with type aliases in polymorphic mode (monomorphic part of \cd{Visitors} compiles successfully).
    \begin{lstlisting}
    type ('a,'b) t = Foo of 'a * 'b (* OK *)
    [@@deriving visitors { variety = "map"; polymorphic = true }]
    type 'a t2 = ('a, int) t
    [@@deriving visitors { variety = "map"; name="yyy"; polymorphic = true }]
    \end{lstlisting}
    The generated code can be fixed manually by removing explicit polymorphic type annotations from objects' methods which leads to the code very similar to the one being generated by GT. From these we can deduce that GT is reimplementation of polymorphic part of visitors where more type declarations compile successfully.
\end{itemize}
