\begin{figure}[t]
  \center
  \begin{tabular}{l|l}
    \hline
    \multicolumn{2}{c}{\cd{camlp5} version}\\
    \hline
    \lstinline|@type ... $[$ with  $p_1, p_2, \dots$ $]$| & a syntax construct to generate a support for a type \\
                                                         & with plugins $p_1, p_2, \dots$; mutually recursive definitions \\
                                                         & are supported \\
    \lstinline|@$typ$| & the name for the virtual class for type $typ$ \\
    \lstinline|@$plugin$[$typ$]| & the name for a plugin class for type $typ$ and \\
                                 & plugin $plugin$\\
    \hline
        \multicolumn{2}{c}{\cd{ppxlib} version}\\
    \hline
    \lstinline|type ... = ...|  & a syntax construct to generate a support for a type \\
    \lstinline|and  ... = ...|  & with plugins $p_1, p_2, \dots$ \\
    \lstinline|[@@deriving gt ~options:{ $p_1, p_2, \dots$}]|
  \end{tabular}
  \caption{Extended Syntax Constructs}
  \label{syntax}
\end{figure}

\section{Implementation}

The main components of our solution are syntax extensions (both in terms of \cd{camlp5}~\cite{Camlp5} and \cd{ppxlib}~\cite{PPXLib}), a runtime library and
a plugin system. The syntax extensions process type definitions, attributed by an end user, and generate the following entities:

\begin{itemize}
\item a transformation function (one per a type);
\item a virtual class, which is used as a common ancestor for all concrete transformations;
\item a number of concrete classes (one per requested plugin);
\item a \emph{typeinfo} structure, which incorporates the transformation function and a bundle of plugin-generated concrete functions, represented as an immediate object.
\end{itemize}

We support the majority of variants in the right-hand side of type definitions with the following limitations:

\begin{itemize}
\item only regular algebraic data types are supported; GADTs are treated as simple algebraic datatypes;
\item constraints are not taken into account;
\item ``\lstinline{nonrec}'' definitions, object and module types are not supported;
\item extensible datatypes (``\lstinline{...}''/``\lstinline{+=}'') are not supported.
\end{itemize}

For example, for a type ``\lstinline{t}'' with requested plugin ``\lstinline{show}'' the structure with the following skeleton is generated (``$\dots$'' stands for the parts we omit for now):

\begin{lstlisting}
   let $\inbr{gcata_t}$ $\dots$ = $\dots$
   
   class virtual [$\dots$] $\inbr{t}$ $\dots$ =
   object
     $\dots$
   end

   class [$\dots$] $\inbr{show_t}$ $\dots$ =
   object inherit [$\dots$] $\inbr{t}$ $\dots$
     $\dots$
   end

   let t = {
     gcata   = $\inbr{gcata_t}$;
     plugins = object
                 method show = $\dots$
               end
   }
\end{lstlisting}

Using the typeinfo structure ``\lstinline{t}'' we can mimick the type-indexed nature of concrete transformations:

\begin{lstlisting}
   let transform typeinfo = typeinfo.gcata
   let show      typeinfo = typeinfo.plugins#show
\end{lstlisting}

The function ``\lstinline{transform(t)}'' is a top-level transformation function, which can be instantiated for any supported type ``\lstinline{t}''. On the
Figure~\ref{syntax} we describe the concrete constructs, implemented by the syntax extensions. Note, the concrete way of encoding names
for classes and transformation function (represented above as $\inbr{...}$) is not important as long as \cd{camlp5} is
used since it provides corresponding syntax extensions.

\subsection{Types of Transformations}

The design of the library is based on the idea to describe transformations (e.g. catamorphisms~\cite{Bananas}) in terms of attribute grammars~\cite{AGKnuth,AGSwierstra,ObjectAlgebrasAttribute}.
In short, we consider only the transformations of the following type

\[
\iota \to t \to \sigma
\]

where $t$ is the type of a value to transform, $\iota$ and $\sigma$~--- types for \emph{inherited} and \emph{synthesized} attributes. We do not use attribute
grammars as a mean to describe the algorithmic part of transformations; we only utilize their terminology to describe the types. 

When the type under consideration is parameterized, the transformation becomes parameterized as well. From now on we will use a convention to
denote $\left\{...\right\}$ multiple ocurrences of a an entity inside the brackets. Under this convention we may stipulate the generic form of
any transformation, representable with the aid of our library, as

\[
  \left\{\iota_i \to \alpha_i \to \sigma_i\right\}\to\iota \to\left\{\alpha_i\right\}\;t \to \sigma
\]

Here $\iota_i\to\alpha_i\to\sigma_i$ is an argument-transforming function for the type parameter $\alpha_i$. In general the argument-transforming functions operate on
inherited values of different types and return synthesized values of different types. The common ancestor class in turn is massively polymorphic: for an $n$-parametric
type it receives $3(n+1)$ type parameters:

\begin{itemize}
\item a triplet $\alpha_i$, $\iota_i$, $\sigma_i$ for each type parameter $\alpha_i$, where $\iota_i$ and $\sigma_i$ are type variables for inherited and
  synthesized attributes for the transformation of $\alpha_i$;
\item a pair of type variables $\iota$ and $\sigma$ for inherited and synthesized attributes for the type itself;
\item an extra type variable $\epsilon$, which is needed solely for the support of polymorphic variants (see Section~\ref{pv}) and left free and unused
  otherwise.
\end{itemize}

Apart from being polymorphic, the common ancestor class receives a number of functional arguments:

\begin{itemize}
\item a function to implement open recursion: \lstinline|fself : $\iota$ -> $\left\{\alpha_i\right\}$ t ->  $\sigma$|;
\item $n$ argument-transforming functions: \lstinline|f$_{\alpha_i}$ : $\iota_i$ -> $\alpha_i$ -> $\sigma_i$|.
\end{itemize}

For example, if we have a two-parametric type \lstinline{($\alpha$, $\beta$) t} the head of common ancestor class definition will look like

\begin{lstlisting}
  class virtual [$\iota_\alpha$, $\alpha$, $\sigma_\alpha$, $\iota_\beta$, $\beta$, $\sigma_\beta$, $\iota$, $\epsilon$, $\sigma$] $\inbr{t}$
    (fself : $\iota$ -> ($\alpha$, $\beta$) t -> $\sigma$)
    (f$_\alpha$ : $\iota_\alpha$ -> $\alpha$ -> $\sigma_\alpha$)
    (f$_\beta$ : $\iota_\beta$ -> $\beta$ -> $\sigma_\beta$)
\end{lstlisting}

Note, we maintain these conventions for all types although for some of them some of components are superfluous: for example, ``\lstinline{fself}''
is needed only for recursive types. The explanation for this decision is simple: when we \emph{use} a type we generally do not know its
definition. Thus, in order to support separate compilation the interfaces of all entities we generate must have identical structure.

This scheme of typing and parameterization looks quite verbose and cumbersome: there are a lot of type parameters which are quite easy to get a mess with. However, an end
user would need to deal with this stuff directly only when he or she desires to implement a transformation \emph{manually} from scratch by immediately inheriting from the common ancestor class.
In the majority of use cases the transformation is implemented either by customizing a certain plugin or using the plugin system. In the first case many
type parameters are already instantiated (for example, for ``\lstinline{show}'' the majority of type parameters are instantiated to ground types), in the
second the plugin system takes care of instantiating the parameters correctly (see Section~\ref{plugins}).

Finally, we need to describe the types for the methods of common ancestor classes. For a type \lstinline|$\left\{\alpha_i\right\}$ t| the method for a
 constructor ``\lstinline|C of a$_1$ * a$_2$ * ... * a$_k$|'' has the following definition:

\begin{lstlisting}
   method virtual $\inbr{C}$ : $\iota$ -> $\left\{\alpha_i\right\}$ t -> a$_1$ -> a$_2$ -> ... -> a$_k$ -> $\sigma$
\end{lstlisting}

Note, the method takes not only inherited attribute and the arguments of corresponding constructor, but the value under transformation itself.

\subsection{Fixed Point Combinator and Memoization}

In our approach we use open recursion: a class for a concrete transformation takes a function for the same transformation as a parameter. In order
to instantiate this function we have to use a fixpoint combinator. In this section we consider only a simple fixpoint combinator for an isolated
type definition; in mutually-recursive case a more elaborated combinator is needed (see Section~\ref{murec}).

We repeat here an example from Section~\ref{expo}:

\begin{lstlisting}
   let $\inbr{pretty_{expr}}$ e =
     fix (fun fself p e -> $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ fself) p e) min_int e
\end{lstlisting}

As the lambda argument of ``\lstinline{fix}'' is called each time when ``\lstinline{fself}'' is called (virtually, for each node of
an expression), a new transformation object is created for each node. As all these objects are identical, this calls for an optimization. 

We memoize the creation of transformation objects using lazy evaluation. For this we abstract object creation into a
function which takes ``\lstinline{fself}'' as an argument. Then the implementation of the fixpoint combinator is as follows:

\begin{lstlisting}
   let fix gcata make_obj $\iota$ x =
     let rec obj = lazy (make_obj fself)
     and fself $\iota$ x = gcata (Lazy.force obj) $\iota$ x in
     fself $\iota$ x
\end{lstlisting}

This combinator can be used for all types and is not generated. Now we can fix a little bit the definition of ``\lstinline{transform}'':

\begin{lstlisting}
   let transform typeinfo = fix typeinfo.gcata
\end{lstlisting}

With this definition an end used does not need to deal with the fixpoint combinator explicitly anymore:

\begin{lstlisting}
   let $\inbr{show_{expr}}$ e =
     transform(expr) (fun fself -> new $\inbr{show_{expr}}$ fself) () e
\end{lstlisting}

\subsection{Polymorphic Variants}
\label{pv}

%Open recursion is vital for polymorphic variants support, since concrete transformations can be used for any type which contains a given one as a constituent.

\subsection{Mutual Recursion}
\label{murec}

\subsection{Plugin System}

\label{plugins}
