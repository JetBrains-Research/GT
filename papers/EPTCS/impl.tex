\begin{figure}[t]
  \center
  \begin{tabular}{c|l}
    \hline
    \multicolumn{2}{c}{\cd{camlp5} version}\\
    \hline
    \lstinline|@type ... $[$ with  $p_1, p_2, \dots$ $]$| & a syntax construct to generate a support for a type \\
                                                         & with plugins $p_1, p_2, \dots$; mutually recursive definitions \\
                                                         & are supported \\
    \lstinline|@$typ$| & the name for the virtual class for type $typ$ \\
    \lstinline|@$plugin$[$typ$]| & the name for a plugin class for type $typ$ and \\
                                 & plugin $plugin$\\
    \hline
        \multicolumn{2}{c}{\cd{ppxlib} version}\\
    \hline
  \end{tabular}
  \caption{Extended Syntax Constructs}
  \label{syntax}
\end{figure}

\section{Implementation}

The main components of our solution are syntax extensions (both in terms of \cd{camlp5}~\cite{Camlp5} and \cd{ppxlib}~\cite{PPXLib}), a runtime library and
a plugin system. The syntax extensions process type definitions, attributed by an end user, and generate the following entities:

\begin{itemize}
\item a transformation function (one per a type);
\item a virtual class, which is used as a common ancestor for all concrete transformations;
\item a number of concrete classes (one per requested plugin);
\item a \emph{typeinfo} structure, which incorporates the transformation function and a bundle of plugin-generated concrete functions, represented as an immediate object.
\end{itemize}

We support the majority of variants in the right-hand side of type definitions with the following limitations:

\begin{itemize}
\item only regular algebraic data types are supported; GADTs are treated as simple algebraic datatypes;
\item constraints are not taken into account;
\item ``\lstinline{nonrec}'' definitions, object and module types are not supported;
\item extensible datatypes (``\lstinline{...}''/``\lstinline{+=}'') are not supported.
\end{itemize}

For example, for a type ``\lstinline{t}'' with requested plugin ``\lstinline{show}'' the structure with the following skeleton is generated (``$\dots$'' stands for the parts we omit for now):

\begin{lstlisting}
   let $\inbr{transform_t}$ $\dots$ = $\dots$
   
   class virtual [$\dots$] $\inbr{t}$ $\dots$ =
   object
     $\dots$
   end

   class [$\dots$] $\inbr{show_t}$ $\dots$ =
   object inherit [$\dots$] $\inbr{t}$ $\dots$
     $\dots$
   end

   let t = {
     gcata   = $\inbr{transform_t}$;
     plugins = object
                 method show = $\dots$
               end
   }
\end{lstlisting}

Using the typeinfo structure we may mimick the type-indexed nature of concrete transformations:

\begin{lstlisting}
   let transform x = x.gcata
   let show      x = x.plugins#show
\end{lstlisting}

Thus, ``\lstinline{transform(t)}'' becomes the representation for ``$\inbr{transform_t}$'' in the concrete syntax, etc. On the
Figure~\ref{syntax} we describe the concrete constructs, implemented by the syntax extensions. Note, the concrete way of encoding names
for classes and transformation function (represented above as $\inbr{...}$) is not important as long as \cd{camlp5} is
used since it provides corresponding syntax extensions.


\subsection{Types of Transformations}

The design of the library is based on the idea to describe transformations (e.g. catamorphisms~\cite{Bananas}) in terms of attribute grammars~\cite{AGKnuth,AGSwierstra,ObjectAlgebrasAttribute}.
In short, we consider only the transformations of the following type

\[
\iota \to t \to \sigma
\]

where $t$ is the type of a value to transform, $\iota$ and $\sigma$~--- types for \emph{inherited} and \emph{synthesized} attributes. We do not use attribute
grammars as a mean to describe the algorithmic part of transformations; we only utilize their terminology to describe the types. 

When the type under consideration is parameterized, the transformation becomes parameterized as well. From now on we will use a convention to
denote $\left\{...\right\}$ multiple ocurrences of a an entity inside brackets. Under this convention we may stipulate the generic form of
any transformation, representable with the aid of our library, as

\[
  \left\{\iota_i \to \alpha_i \to \sigma_i\right\}\to\iota \to\left\{\alpha_i\right\}\;t \to \sigma
\]

Here $\iota_i\to\alpha_i\to\sigma_i$ is an argument-transforming function for the type parameter $\alpha_i$. In general the argument-transforming functions operate on
inherited values of different types and return synthesized values of different types.

\subsection{Fixed Point Combinator and Memoization}

\subsection{Polymorphic Variants}

\subsection{Mutual Recursion}
