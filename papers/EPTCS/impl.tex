\section{Implementation}

From an end user perspective, our library is comprised of four layers:

\begin{enumerate}
\item On the top level it provides a syntax extension (in terms of both \cd{camlp5} and \cd{ppxlib}) with a number of plugins
(\cd{map}, \cd{fold}, \cd{show}, etc.) The interface of generated features is combinatorial, so their utilization is rather straightforward.
  
\item On the middle level it turns out, that all these features are implemented via object-encoded transformations with some reasonable
default behavior. This behavior can be modified/overridden using inheritance. Thus, customized transformations can be acquired using
the default ones.

\item On the low level it turns out, that all features are in fact instantiations of some very general transformation scheme; thus, transformations,
which do not fit in any pre-supplied plugin can still be implemented manually.
  
\item In the basement, the users can implement their own plugins; note, since all plugins are just instantiations of some generic scheme, the implementation
requires only a limited amount of work. In particular, all plugins use the same single traversal function, which need not to be generated.
\end{enumerate}

In fact, there is also an underground layer~--- all generic features are combined into an object, which can be passed as a parameter or modified. While
currently the library does not contain any conventional interface to deal with the object, it can be provided in the future (which opens a potentially
interesting opportunities for integration with existing proposals for \emph{ad-hoc} polymorphism~\cite{ModularImplicits}).



The design of the library is based on the idea to describe transformations (e.g. catamorphisms~\cite{Bananas}) in terms of transformations, described by
attribute grammars~\cite{AGKnuth,AGSwierstra}. In short, we consider only the transformations of the following type

\[
\iota \to t \to \sigma
\]

where $t$ is the type of value to transform, $\iota$ and $\sigma$~--- types for \emph{inherited} and \emph{synthesized} values. We do not use attribute
grammars as a mean to describe the algorithmic part of transformations; we only utilize their terminology to describe the types of transformations.

When the type under consideration is parameterized, the transformation becomes parameterized as well:

\begin{tabular}{cl}
  $(\iota_1 \to \alpha_1 \to \sigma_1) \to$ & \\
  $\dots$                                  & \\
  $(\iota_k \to \alpha_k \to \sigma_k) \to$ & $\iota \to (\alpha_1,\dots,\alpha_k)\;t \to \sigma$
\end{tabular}

In general the argument-transforming functions operate on inherited values of different types and return synthesized values of different types.

The second idea is to encode a transformation for an algebraic data type as an object with per-constructor transformation methods (the similar idea is
used in~\cite{Visitors}). For example, for a type

\begin{lstlisting}
  type $\alpha$ t = A of $\alpha$ | B of $\alpha$ t * $\alpha$ t 
\end{lstlisting}

a transformation object would have the following structure

\begin{lstlisting}
  object
    method c_A : $\iota$ -> $\alpha$ -> $\sigma$
    method c_B : $\iota$ -> $\alpha$ t -> $\alpha$ t -> $\sigma$
  end
\end{lstlisting}

To automatically mass-produce transformation objects, a number of classes is generated: first, the common base virtual class for all transformations for
given type, and then one customized class per feature, requested by mean of plugins. All these classes are concrete, inherit from the
base one and are additionally parameterized by type parameters-transforming functions, including the function for transforming the type itself (thus
using open recursion pattern).

Finally, a single traversal function is generated. It takes a transformation object, an inherited attribute, and a value to traverse, performs pattern-matching
and calls appropriate methods of the object. For the example in question the traversal function may look like

\begin{lstlisting}
  let transform obj $\iota$ = function
  | A x      -> obj # c_A $\iota$ x
  | B (l, r) -> obj # c_B $\iota$ l r
\end{lstlisting}

Note, the traversal function is non-recursive; the recursion (if any) is indirectly handled in object's methods.

Within this infrastructure is turned out to be possible to implement such features as \cd{show}, \cd{fmap}, \cd{fold},
as well as \cd{eq} and \cd{compare}, which usually are expressed in an \emph{ad-hoc} manner in other frameworks\marginnote{cite visitors?}. All these features are
implemented as plugins, which instantiate the generic components. Plugins also generate the top-level functions, tying the recursive knot,
and combine this functions into a data structure with the same name as the type of interest. All plugins supply a (universal) access function,
which takes this data structure as its first parameter. Under these conventions, \cd{show(int)} designates a \cd{show} function for \cd{int}s,
while \cd{fmap(list)}~--- \cd{fmap} for lists.

Beyond this simplified scheme some other things have to be done; for example, a special care has to be taken to support polymorphic variants, which
we consider an important feature of our library.
