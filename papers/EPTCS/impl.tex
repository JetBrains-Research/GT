\begin{figure}[t]
  \center
  \begin{tabular}{c|l}
    \hline
    \multicolumn{2}{c}{\cd{camlp5} version}\\
    \hline
    \lstinline|@type ... $[$ with  $p_1, p_2, \dots$ $]$| & a syntax construct to generate a support for a type \\
                                                         & with plugins $p_1, p_2, \dots$; mutually recursive definitions \\
                                                         & are supported \\
    \lstinline|@$typ$| & the name for a virtual class for type $typ$ \\
    \lstinline|@$plugin$[$typ$]| & the name for a plugin class for type $typ$\\
    \hline
        \multicolumn{2}{c}{\cd{ppxlib} version}\\
    \hline
  \end{tabular}
  \caption{Extended Syntax Constructs}
  \label{syntax}
\end{figure}

\section{Implementation}

The main components of our solution are syntax extensions (both in terms of \cd{camlp5}~\cite{Camlp5} and \cd{ppxlib}~\cite{PPXLib}), a runtime library and
a plugin system. The syntactic extensions process type definitions, attributed by an end user, and generate the following entities:

\begin{itemize}
\item a trasformation function (one per a type);
\item a virtual class, which is used as a common ancestor for all concrete transformations;
\item a number of concrete classes (one per requested plugin);
\item a \emph{typeinfo} structure, which incorporates the transformation function and a bundle of plugin-generated concrete functions, represented as an immediate object.
\end{itemize}

For example, for a type ``\lstinline{t}'' and requested plugins ``\lstinline{show}'', ``\lstinline{gmap}'' and ``\lstinline{fold}'' the structure with the following skeleton is
generated (``$\dots$'' stands for the parts we omit for now):

\begin{lstlisting}
   let $\inbr{transform_t}$ $\dots$ = $\dots$
   
   class virtual [$\dots$] $\inbr{t}$ $\dots$ =
   object
     $\dots$
   end

   class [$\dots$] $\inbr{show_t}$ $\dots$ =
   object inherit [$\dots$] $\inbr{t}$ $\dots$
     $\dots$
   end

   class [$\dots$] $\inbr{gmap_t}$ $\dots$ =
   object inherit [$\dots$] $\inbr{t}$ $\dots$
     $\dots$
   end

   class [$\dots$] $\inbr{fold_t}$ $\dots$ =
   object inherit [$\dots$] $\inbr{t}$ $\dots$
     $\dots$
   end

   let t = {
     gcata   = $\inbr{transform_t}$;
     plugins = object
                 method show = $\dots$
                 method gmap = $\dots$
                 method fold = $\dots$
               end
   }
\end{lstlisting}

Using the typeinfo structure we may mimick the type-indexed nature of the transformations:

\begin{lstlisting}
   let transform x = x.gcata
   let show      x = x.plugins#show
   let gmap      x = x.plugins#gmap
   let fold      x = x.plugins#fold
\end{lstlisting}

Thus, ``\lstinline{transform(t)}'' becomes the representation for ``$\inbr{transform_t}$'' in concrete syntax, etc. In the
Figure~\ref{syntax} we describe the concrete constructs, implemented by the syntax extensions.

\subsection{Types of Transformations}

The design of the library is based on the idea to describe transformations (e.g. catamorphisms~\cite{Bananas}) in terms of attribute grammars~\cite{AGKnuth,AGSwierstra,ObjectAlgebrasAttribute}.
In short, we consider only the transformations of the following type

\[
\iota \to t \to \sigma
\]

where $t$ is the type of a value to transform, $\iota$ and $\sigma$~--- types for \emph{inherited} and \emph{synthesized} values. We do not use attribute
grammars as a mean to describe the algorithmic part of transformations; we only utilize their terminology to describe the types of transformations. 

When the type under consideration is parameterized, the transformation becomes parameterized as well:

\begin{tabular}{cl}
  $(\iota_1 \to \alpha_1 \to \sigma_1) \to$ & \\
  $\dots$                                  & \\
  $(\iota_k \to \alpha_k \to \sigma_k) \to$ & $\iota \to (\alpha_1,\dots,\alpha_k)\;t \to \sigma$
\end{tabular}

In general the argument-transforming functions operate on inherited values of different types and return synthesized values of different types.

\subsection{Fixed Point Combinator and Memoization}

\subsection{Polymorphic Variants}

\subsection{Mutual Recursion}
