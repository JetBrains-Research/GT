\begin{figure}[t]
  \center
  \begin{tabular}{l|l}
    \hline
    \multicolumn{2}{c}{\cd{camlp5} version}\\
    \hline
    \lstinline|@type ... $[$ with  $p_1, p_2, \dots$ $]$| & a syntax construct to generate a support for a type \\
                                                         & with plugins $p_1, p_2, \dots$; mutually recursive definitions \\
                                                         & are supported \\
    \lstinline|@$typ$| & the name for the virtual class for type $typ$ \\
    \lstinline|@$plugin$[$typ$]| & the name for a plugin class for type $typ$ and \\
                                 & plugin $plugin$\\
    \hline
        \multicolumn{2}{c}{\cd{ppxlib} version}\\
    \hline
    \lstinline|type ... = ...|  & a syntax construct to generate a support for a type \\
    \lstinline|and  ... = ...|  & with plugins $p_1, p_2, \dots$ \\
    \lstinline|[@@deriving gt ~options:{ $p_1, p_2, \dots$}]|
  \end{tabular}
  \caption{Extended Syntax Constructs}
  \label{syntax}
\end{figure}

\section{Implementation}

The main components of our solution are syntax extensions (both in terms of \cd{camlp5}~\cite{Camlp5} and \cd{ppxlib}~\cite{PPXLib}), a runtime library and
a plugin system. The syntax extensions process type definitions, attributed by an end user, and generate the following entities:

\begin{itemize}
\item a transformation function (one per a type);
\item a virtual class, which is used as a common ancestor for all concrete transformations;
\item a number of concrete classes (one per requested plugin);
\item a \emph{typeinfo} structure, which incorporates the transformation function and a bundle of plugin-generated concrete functions, represented as an immediate object.
\end{itemize}

We support the majority of variants in the right-hand side of type definitions with the following limitations:

\begin{itemize}
\item only regular algebraic data types are supported; GADTs are treated as simple algebraic datatypes;
\item constraints are not taken into account;
\item ``\lstinline{nonrec}'' definitions, object and module types are not supported;
\item extensible datatypes (``\lstinline{...}''/``\lstinline{+=}'') are not supported.
\end{itemize}

For example, for a type ``\lstinline{t}'' with requested plugin ``\lstinline{show}'' the structure with the following skeleton is generated (``$\dots$'' stands for the parts we omit for now):

\begin{lstlisting}
   let $\inbr{transform_t}$ $\dots$ = $\dots$
   
   class virtual [$\dots$] $\inbr{t}$ $\dots$ =
   object
     $\dots$
   end

   class [$\dots$] $\inbr{show_t}$ $\dots$ =
   object inherit [$\dots$] $\inbr{t}$ $\dots$
     $\dots$
   end

   let t = {
     gcata   = $\inbr{transform_t}$;
     plugins = object
                 method show = $\dots$
               end
   }
\end{lstlisting}

Using the typeinfo structure ``\lstinline{t}'' we can mimick the type-indexed nature of concrete transformations:

\begin{lstlisting}
   let transform x = x.gcata
   let show      x = x.plugins#show
\end{lstlisting}

Thus, ``\lstinline{transform(t)}'' becomes the representation for ``$\inbr{transform_t}$'' in the concrete syntax, etc. On the
Figure~\ref{syntax} we describe the concrete constructs, implemented by the syntax extensions. Note, the concrete way of encoding names
for classes and transformation function (represented above as $\inbr{...}$) is not important as long as \cd{camlp5} is
used since it provides corresponding syntax extensions.


\subsection{Types of Transformations}

The design of the library is based on the idea to describe transformations (e.g. catamorphisms~\cite{Bananas}) in terms of attribute grammars~\cite{AGKnuth,AGSwierstra,ObjectAlgebrasAttribute}.
In short, we consider only the transformations of the following type

\[
\iota \to t \to \sigma
\]

where $t$ is the type of a value to transform, $\iota$ and $\sigma$~--- types for \emph{inherited} and \emph{synthesized} attributes. We do not use attribute
grammars as a mean to describe the algorithmic part of transformations; we only utilize their terminology to describe the types. 

When the type under consideration is parameterized, the transformation becomes parameterized as well. From now on we will use a convention to
denote $\left\{...\right\}$ multiple ocurrences of a an entity inside brackets. Under this convention we may stipulate the generic form of
any transformation, representable with the aid of our library, as

\[
  \left\{\iota_i \to \alpha_i \to \sigma_i\right\}\to\iota \to\left\{\alpha_i\right\}\;t \to \sigma
\]

Here $\iota_i\to\alpha_i\to\sigma_i$ is an argument-transforming function for the type parameter $\alpha_i$. In general the argument-transforming functions operate on
inherited values of different types and return synthesized values of different types. The common ancestor class in turn is massively polymorphic: for an $n$-parametric
type it receives $3(n+1)$ type parameters:

\begin{itemize}
\item a triplet $\alpha_i$, $\iota_i$, $\sigma_i$ for each type parameter $\alpha_i$, where $\iota_i$ and $\sigma_i$ are type variables for inherited and
  synthesized attributes for the transformation of $\alpha_i$;
\item a pair of type variables $\iota$ and $\sigma$ for inherited and synthesized attributes for the type itself;
\item an extra type variable $\epsilon$, which is needed solely for the support of polymorphic variants (see Section~\ref{pv}) and left free and unused
  otherwise.
\end{itemize}

Apart from being polymorphic, the common ancestor class receives a number of functional arguments:

\begin{itemize}
\item a function to implement open recursion: \lstinline|fself : $\iota$ -> $\left\{\alpha_i\right\}$ t ->  $\sigma$|;
\item $n$ argument-transforming functions: \lstinline|f$_{\alpha_i}$ : $\iota_i$ -> $\alpha_i$ -> $\sigma_i$|.
\end{itemize}

For example, if we have a two-parametric type \lstinline{($\alpha$, $\beta$) t} the head of common ancestor class definition will look like

\begin{lstlisting}
  class virtual [$\iota_\alpha$, $\alpha$, $\sigma_\alpha$, $\iota_\beta$, $\beta$, $\sigma_\beta$, $\iota$, $\epsilon$, $\sigma$] $\inbr{t}$
    (fself : $\iota$ -> ($\alpha$, $\beta$) t -> $\sigma$)
    (f$_\alpha$ : $\iota_\alpha$ -> $\alpha$ -> $\sigma_\alpha$)
    (f$_\beta$ : $\iota_\beta$ -> $\beta$ -> $\sigma_\beta$)
\end{lstlisting}

This scheme of typing and parameterization looks quite verbose and cumbersome: there are a lot of type parameters which are quite easy to get a mess with. However, an end
user would need to deal with this stuff directly only when he or she desires to implement a transformation \emph{manually} from scratch by immediately inheriting from the common ancestor class.
In the majority of use cases the transformation is implemented either by customizing a certain plugin or using the plugin system. In the first case many
type parameters are already instantiated (for example, for ``\lstinline{show}'' the majority of type parameters are instantiated to ground types), in the
second the plugin system takes care of instantiating the parameters correctly (see Section~\ref{plugins}).

Finally, we need to describe the types for the methods of common ancestor classes. For a type \lstinline|$\left\{\alpha_i\right\}$ t| the method for a
 constructor ``\lstinline|C of a$_1$ * a$_2$ * ... * a$_k$|'' has the following definition:

\begin{lstlisting}
   method virtual $\inbr{C}$ : $\iota$ -> $\left\{\alpha_i\right\}$ t -> a$_1$ -> a$_2$ -> ... -> a$_k$ -> $\sigma$
\end{lstlisting}

Note, the method takes not only inherited attribute and the arguments of corresponding constructor, but the value under transformation itself.

\subsection{Fixed Point Combinator and Memoization}

\subsection{Polymorphic Variants}
\label{pv}

\subsection{Mutual Recursion}
\subsection{Plugin System}
\label{plugins}
