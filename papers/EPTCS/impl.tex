\section{Implementation}

The design of the library is based on the idea to describe transformations (e.g. catamorphisms~\cite{Bananas}) in terms of attribute grammars~\cite{AGKnuth,AGSwierstra,ObjectAlgebrasAttribute}.
In short, we consider only the transformations of the following type

\[
\iota \to t \to \sigma
\]

where $t$ is the type of a value to transform, $\iota$ and $\sigma$~--- types for \emph{inherited} and \emph{synthesized} values. We do not use attribute
grammars as a mean to describe the algorithmic part of transformations; we only utilize their terminology to describe the types of transformations. 

Our framework provides syntax extensions both in terms of \cd{camlp5}~\cite{Camlp5} and \cd{ppxlib}~\cite{PPXLib}
The main components of 
When the type under consideration is parameterized, the transformation becomes parameterized as well:

\begin{tabular}{cl}
  $(\iota_1 \to \alpha_1 \to \sigma_1) \to$ & \\
  $\dots$                                  & \\
  $(\iota_k \to \alpha_k \to \sigma_k) \to$ & $\iota \to (\alpha_1,\dots,\alpha_k)\;t \to \sigma$
\end{tabular}

In general the argument-transforming functions operate on inherited values of different types and return synthesized values of different types.

The second idea is to encode a transformation for an algebraic data type as an object with per-constructor transformation methods (the similar idea is
used in~\cite{Visitors}). For example, for a type

\begin{lstlisting}
  type $\alpha$ t = A of $\alpha$ | B of $\alpha$ t * $\alpha$ t 
\end{lstlisting}

a transformation object would have the following structure

\begin{lstlisting}
  object
    method c_A : $\iota$ -> $\alpha$ -> $\sigma$
    method c_B : $\iota$ -> $\alpha$ t -> $\alpha$ t -> $\sigma$
  end
\end{lstlisting}

To automatically mass-produce transformation objects, a number of classes is generated: first, the common base virtual class for all transformations for
given type, and then one customized class per feature, requested by mean of plugins. All these classes are concrete, inherit from the
base one and are additionally parameterized by type parameters-transforming functions, including the function for transforming the type itself (thus
using open recursion pattern).

Finally, a single traversal function is generated. It takes a transformation object, an inherited attribute, and a value to traverse, performs pattern-matching
and calls appropriate methods of the object. For the example in question the traversal function may look like

\begin{lstlisting}
  let transform obj $\iota$ = function
  | A x      -> obj # c_A $\iota$ x
  | B (l, r) -> obj # c_B $\iota$ l r
\end{lstlisting}

Note, the traversal function is non-recursive; the recursion (if any) is indirectly handled in object's methods.

Within this infrastructure is turned out to be possible to implement such features as \cd{show}, \cd{fmap}, \cd{fold},
as well as \cd{eq} and \cd{compare}, which usually are expressed in an \emph{ad-hoc} manner in other frameworks. All these features are
implemented as plugins, which instantiate the generic components. Plugins also generate the top-level functions, tying the recursive knot,
and combine this functions into a data structure with the same name as the type of interest. All plugins supply a (universal) access function,
which takes this data structure as its first parameter. Under these conventions, \cd{show(int)} designates a \cd{show} function for \cd{int}s,
while \cd{fmap(list)}~--- \cd{fmap} for lists.

Beyond this simplified scheme some other things have to be done; for example, a special care has to be taken to support polymorphic variants, which
we consider an important feature of our library.
