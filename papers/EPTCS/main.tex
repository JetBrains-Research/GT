\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{ML 2018}  % Name of the event you are submitting to
\usepackage{breakurl}             % Not needed if you use pdflatex only.
\usepackage{underscore}           % Only needed if you use pdflatex.

\usepackage{marginnote}
\usepackage{booktabs} 
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{multirow}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{comment}
\usepackage{wrapfig}
\usepackage[caption=false]{subfig}
\usepackage{placeins}
\usepackage{tabularx}
\usepackage{ragged2e}
\usepackage{soul}
\usepackage{csquotes}
\usepackage{inconsolata}

\lstdefinelanguage{ocaml}{
keywords={@type, function, fun, let, in, match, with, when, class, type,
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, success, failure,
assert, true, false, end},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\bfseries, %\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {\\/}{{$\vee$}}2 {/\\}{{$\wedge$}}2 {>=}{{$\ge$}}1 {<=}{{$\le$}} 1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
%basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=ocaml
}

\newcommand{\cd}[1]{\texttt{#1}}
\newcommand{\inbr}[1]{\left<#1\right>}
%\pagestyle{plain}
%\sloppy

\title{Generic Programming with Combinators and Objects}

\author{Dmitry Kosarev
  \institute{St. Petersburg State University\\
    JetBrains Research \\
    St. Petersburg, Russia}
\email{Dmitrii.Kosarev@protonmail.ch}
\and
Dmitry Boulytchev
\institute{St. Petersburg State University\\
  JetBrains Research \\
  St. Petersburg, Russia}
\email{dboulytchev@math.spbu.ru}
}

\def\titlerunning{Generic Programming with Combinators and Objects}
\def\authorrunning{D.Kosarev, D.Boulytchev}
\begin{document}
\maketitle

\begin{abstract}
  We present a generic programming framework for \textsc{OCaml} which allows to implement extensible
  transformations 
\end{abstract}

\input{intro.tex}
\input{exposition.tex}
\input{impl.tex}

\section{Examples}

In this section we demonstrate some examples, written with the aid of our library. In this examples we will use \cd{camlp5} syntax extension,
although \cd{ppxlib} plugin can be used equally.

First, we consider a simple type to represent arithmetic expressions:

\begin{lstlisting}
@type expr = Var   of string
           | Add   of expr * expr
           | Mul   of expr * expr
           | Div   of expr * expr
           | Const of int         with fmap
\end{lstlisting}

Here we requested a feature \cd{fmap}, which implements the conventional functor semantics. Since the type is not polymorphic, the function \cd{fmap(expr)}
just copies its argument. Although the copying can be considered useful on its own, this result a bit disappointing. However, with the aid of our framework we
actually can acquire a number of useful transformations, taking the copying as the starting point. For example, given a state \cd{st} we can substitute the
values of all variables in this state in an expression:
\marginnote{We omitted a method's argument for value being transformed. Is it intentional?}

\begin{lstlisting}
  let substitute st e = fix
    (fun f ->
       transform(expr)
         (object inherit [_] @expr[fmap] f
            method c_Var _ x = Const (st x)
          end)
          ()
    ) e
\end{lstlisting}

Indeed, all we need is to redefine the copy behavior for constructor \cd{Var}. In order to do this we inherit from the class \cd{fmap} for the type
\cd{expr} (denoted by \cd{@expr[gmap]} in the snippet), and rewrite the method \cd{c\_Var} (note the use of generic function \cd{transform(expr)} and
fix point combinator). As it can be seen from this example, we needed to implement only ``the interesting'' part of the transformation. All other
functionality (recursive propagation through the whole data structure) is handled by a framework-generated code.

For another example we consider an expression simplifier, which performs all possible calculations with constants and utilizes some
simple arithmetic equalities like $0*x=0$ or $0+x=x$:

\begin{lstlisting}
  class simplifier f =
  object 
    inherit [_] @expr[fmap] f
    method c_Div _ x y =
      match f x, f y with
      | Const x, Const y -> Const (x / y)
      | x      , Const 1 -> x
      | x      , y       -> Div (x, y)
    method c_Mul _ x y =
      match f x, f y with
      | Const x, Const y        -> Const (x * y)
      | Const 0, _ | _, Const 0 -> Const 0
      | Const 1, y              -> y
      | x, Const 1              -> x
      | x, y                    -> Mul (x, y)
    method c_Add _ x y =
      match f x, f y with
      | Const x, Const y -> Const (x + y)
      | Const 0, y       -> y
      | x, Const 0       -> x
      | x, y             -> Add (x, y)
  end
\end{lstlisting}

Since the interesting part is concentrated in the class definition, we omitted the top-level function, which looks exactly like the previous one,
since we are still dealing with the same feature \cd{fmap}. The class definition is much longer, than the previous one, but this is
inevitable~--- the interesting part is that long, indeed.

Note, the simplifier we implemented is strict~--- it evaluates both operands of a multiplication even if the first is equal 0. We can implement
a non-strict simplifier on top of the strict one:

\begin{lstlisting}
  class ns_simplifier f =
  object 
    inherit simplifier f 
    method c_Mul _ x y =
      match f x with
      | Const 0 -> Const 0
      | Const 1 -> f y
      | Const x -> (match f y with
                    | Const y -> Const (x * y)
                    | y       -> Mul   (Const x, y)
                    )
      | x       -> (match f y with
                    | Const 0 -> Const 0
                    | Const 1 -> x
                    | y       -> Mul (x, y)
                    )
  end
\end{lstlisting}

Again, this definition consists of only interesting part.

Finally, with substitutions an simplifications we can define an evaluation (first substitute, then simplify). Thus, the object layer of our framework
provides us with the powerful tool to create and modify transformations.

For another example we take the support for polymorphic variants~\cite{PolyVar,PolyVarReuse}, which we consider an important feature since it complements
the opportunity to provide composable data structures with the opportunity to create composable transformations. For the concrete problem we take the
transformation from named to nameless representations for lambda terms.

First, we define the generic part of the terms:

\begin{lstlisting}
  @type ('name, 'lam) lam = [
  | `App of 'lam * 'lam
  | `Var of 'name
  ] with eval
\end{lstlisting}

The \cd{eval} plugin here generates a transformation \cd{eval(lam)}, which is analogous to \cd{fmap}, but additionally uses some environment, which
by default is propagated unchanged. We here follow~\cite{PolyVarReuse} and use an open non-recursive definition of the type; our \cd{eval} corresponds
to \cd{map} in terms of~\cite{Visitors}.

Then, we define a binding construct~--- abstraction:

\begin{lstlisting}
  @type ('name, 'term) abs = [
  | `Abs of 'name * 'term
  ] with eval
  
  class ['term, 'term2] de_bruijn ft =
  object
    inherit [string, unit, 'term, 'term2,
             string list, 'term2] @abs[eval]
      (fun _ -> assert false)
      (fun _ _ -> ())
      ft
    method c_Abs env name term =
      `Abs ((), ft (name :: env) term)
  end
\end{lstlisting}

This time we have to define a conversion transformation since for the abstraction the default behavior of \cd{eval} is not
enough. We introduce the subclass for \cd{@abs[eval]}, in which we specify the type of the environment (\lstinline{string list}),
the representations for names in the input and output values (\lstinline{string} and \lstinline{unit} respectively), and
representations for subterms in the input and output values (abstract for now). The last, sixth type parameter for \cd{@abs[eval]}
is needed for open recursion. The semantics of the single method of this class reflects the normal behavior of the
abstraction during the conversion into the nameless representation: it adds the variable to the environment and uses this
environment to convert the subterm. The parameter \lstinline{ft} corresponds to the subterm conversion transformation. Since
we do not know it yet, we have to abstract over it.

Now we can combine two types into the single type for lambda terms:

\begin{lstlisting}
  @type ('n, 'b) term = [
  | ('n, ('n, 'b) term) lam
  | ('b, ('n, 'b) term) abs
  ] with eval

  @type named    = (string, string) term
  @type nameless = (int, unit) term
\end{lstlisting}

Here we distinguish names in binder positions (\lstinline{'b}) and bound positions (\lstinline{'n}) since their behavior during the
transformation essentially different: names in binder positions are erased, while in bound positions are substituted with corresponding
de Bruijn index. We also define shortcuts for the terms in named and nameless representations.

Similarly to the types, the transformations can be combined as well:

\begin{lstlisting}
  class de_bruijn fself =
  object
    inherit [string, int, string, unit,
             string list, nameless] @term[eval]
       fself
       ith
       (fun _ _ -> ())
    inherit [named, nameless] Abs.de_bruijn fself
  end
\end{lstlisting}

For the generic part of the terms we reused the \cd{eval} transformation, while for abstractions we took the customized one (\lstinline{de_bruijn}); in
any case the final transformation is build via inheritance with no other glue; here \lstinline{ith} is a function, which finds names in an
environment and returns their indices.

It is interesting, that with polymorphic variants is becomes possible to define a transformation with an output type, different from the input
beyond parameterization:

\begin{lstlisting}
   class ['term, 'term2] de_bruijn' ft =
   object
     inherit [string, string list, unit,
              'term, string list, 'term2,
              string list, 'term2, 'term] @abs
     method c_Abs env name term =
       `Abs (ft (name :: env) term) 
   end
     
   @type named = [
   | (string, named) lam
   | (string, named) abs
   ] with eval
                     
   @type nameless = [
   | (int, nameless) lam
   | `Abs of nameless
   ] with eval

   class de_bruijn fself =
   object
     inherit [string, int,
              named, nameless,
              string list,
              nameless] @lam[eval] fself ith fself
      inherit [named, nameless] Abs .de_bruijn' fself 
   end
\end{lstlisting}

Please note the implementation of method \lstinline{c_Abs}~--- now it returns a constructor \lstinline{`Add} with \emph{one}
argument. In short, we defined a transformation into a nameless representation, which completely removes the names in binder
positions.

\input{related.tex}

\section{Conclusion}
In this paper we presented an improved version of Generic Transformers, extended by support of PPX rewriters and type abbreviations. Although it 
uses the similar idea as in some related works, we claim that it allows to solve some problems in a more convenient manner.


\nocite{*}
\bibliographystyle{eptcs}
\bibliography{main}
\end{document}
