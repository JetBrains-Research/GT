\section{Examples}

In this section we present some examples, written with the aid of our library. In this examples we will use \cd{camlp5} syntax extension,
although \cd{ppxlib} plugin can be used equally.

\subsection{Typed Logic Values}

The first example arose in the context of our work on strongly typed logical DSL for \textsc{OCaml}~\cite{OCanren}. One of the
most important construct there was a unification of terms with free logical variables, and dealing with such data strutures
involves a lot of tedious and error-prone work. The typical scenario of interaction between a logical and non-logical worlds
is constructing a \emph{gold} containing a data structure with free logical variables and solving it. The solution
provides bindings for these variables, which, in optimistic scenario, do not contain free variables anymore. To construct
a goal one would need a systematic way to introduce logic variables in some typed data structure, and to recover answers~---
a systematic way to return to a plan, non-logical representation.

The (simplified) type for logic values can be defined as follows:

\begin{lstlisting}
   @type 'a logic =
   | V     of int
   | Value of 'a
   with show, gmap
\end{lstlisting}

A logic value can either be a free logic variable (``\lstinline{V}'') or a some other value (``\lstinline{Value}'') which is not
a free variable (but which can possibly contain free variables inside). To convert to- and from- the logic domain we can use the following
functions:

\begin{lstlisting}
   let lift x = Value x
  
   let reify  = function
   | V     _ -> invalid_arg "Free variable"
   | Value x -> x
\end{lstlisting}

The function ``\lstinline{reify}'' raises and exception on a free variable; indeed, if an occurrence of a free variable
is encountered the logic value can no longer be considered as a regular (non-logical) data structure and has to be interpreted
in some other way.

When we dealing with logic data structures we need to have an opportunity to put a free variable in an arbitrary
position. This means that we have to switch to another type, ``lifted'' into the logic domain. For example,
for arithmetic expressions, which we use as an example through the paper, we would need to construct a value like

\begin{lstlisting}
   Value (
     Binop (
       V 1, 
       Value (Const (V 2)),
       V 3
    )
   )
\end{lstlisting}

which has a type ``\lstinline{lexpr}'', defined as

\begin{lstlisting}
   type expr' = Var of string logic | Const of int logic | Binop of lexpr * lexpr
   and  lexpr = expr' logic
\end{lstlisting}

We also need to implement two conversion functions. All these definitions present a typical example of boilerplate code.

With our framework the solution is almost purely declarative\footnote{But we need to switch the compiler into \cd{-rectypes} mode}.
First, we abstract the type of interest, replacing all positions, in which we may desire to place a type variable, with
fresh type parameters:

\begin{lstlisting}
   @type ('string, 'int, 'expr) a_expr =
   | Var   of 'string
   | Const of 'int
   | Binop of 'string * 'expr * 'expr with show, gmap
\end{lstlisting}

Here we abstract the type of everything, but we could equally abstract it only of itself. Note, we make use of two
generic features~--- ``\lstinline{show}'' and ``\lstinline{gmap}''. The first one is needed for debugging purposes, while
the second is essential for our soultion.

Now we can define the logical and non-logical counterparts as customized versions of the abstracted type:

\begin{lstlisting}
   @type expr  = (string, int, expr) a_expr with show, gmap
   @type lexpr = (string logic, int logic, lexpr) a_expr logic with show, gmap
\end{lstlisting}

Note, the ``new'' type ``\lstinline{expr}'' is equivalent to the ``old'' one, thus, this transformation makes no
harm to the existing code.

Finally, the definitions of conversion functions make use of the generic ``\lstinline{gmap}'' feature the
framework provides:

\begin{lstlisting}
   let rec to_logic   expr = gmap(a_expr) lift  lift  to_logic  expr
   let rec from_logic expr = gmap(a_expr) reify reify from_logic @@ reify expr
\end{lstlisting}

As we can see, the support for type constructor application is vital for the success of this scenario. In our prior
implementation~\cite{TransformationObjects} type constructor application was not supported and could not be easily added.

\subsection{Conversion to a Nameless Representation}

Polymorphic variant types make it possible to define composable statically typed and separately compiled data structures~\cite{PolyVarReuse}.
Dealing with them with composable statically typed and separately compiled transformations looks like a natureal idea. The problem of
constructing transformations from separately compiled, strongly typed components is known as ``The Expression Problem''~\cite{ExpressionProblem}, which
is often used as a ``litmus test'' for generic programming frameworks~\cite{ObjectAlgebras,ALaCarte}. In this section we show the solution of
the expression problem with the aid of our framework. For the concrete problem we take the transformation from named to a nameless representations
for lambda terms.

First, we define the generic part of the terms:

\begin{lstlisting}
   @type ('name, 'lam) lam = [
   | `App of 'lam * 'lam
   | `Var of 'name
   ] with eval
\end{lstlisting}

Here we make use of the ``\lstinline{eval}'' plugin, which we mentioned in Section~\ref{plugins}. It generates a transformation ``\lstinline{eval(lam)}''
which is analogous to \lstinline{gmap}, but additionally uses some environment, which by default is propagated unchanged. We here follow~\cite{PolyVarReuse}
and use an open non-recursive definition of the type.

Then, we define a binding construct~--- abstraction:

\begin{lstlisting}
   @type ('name, 'term) abs = [
   | `Abs of 'name * 'term
   ] with eval
\end{lstlisting}
 
\begin{lstlisting}
   class ['term, 'term2] de_bruijn ft =
   object
     inherit [string, unit, 'term, 'term2,
              string list, 'term2] @abs[eval]
       (fun _ -> assert false)
       (fun _ _ -> ())
       ft
     method c_Abs env name term =
       `Abs ((), ft (name :: env) term)
   end
\end{lstlisting}

This time we have to define a conversion transformation since for the abstraction the default behavior of \lstinline{eval} is not
enough. We introduce the subclass for \lstinline{@abs[eval]}, in which we specify the type of the environment (\lstinline{string list}),
the representations for names in the input and output values (\lstinline{string} and \lstinline{unit} respectively), and
representations for subterms in the input and output values (abstract for now). The last, sixth type parameter for \lstinline{@abs[eval]}
is needed for open recursion. The semantics of the single method of this class reflects the normal behavior of the
abstraction during the conversion into the nameless representation: it adds the variable to the environment and uses this
environment to convert the subterm. The parameter \lstinline{ft} corresponds to the subterm conversion transformation. Since
we do not know it yet, we have to abstract over it.

Now we can combine two types into the single type for lambda terms:

\begin{lstlisting}
  @type ('n, 'b) term = [
  | ('n, ('n, 'b) term) lam
  | ('b, ('n, 'b) term) abs
  ] with eval

  @type named    = (string, string) term
  @type nameless = (int, unit) term
\end{lstlisting}

Here we distinguish names in binder positions (\lstinline{'b}) and bound positions (\lstinline{'n}) since their behavior during the
transformation essentially different: names in binder positions are erased, while in bound positions are substituted with corresponding
de Bruijn index. We also define shortcuts for the terms in named and nameless representations.

Similarly to the types, the transformations can be combined as well:

\begin{lstlisting}
  class de_bruijn fself =
  object
    inherit [string, int, string, unit,
             string list, nameless] @term[eval]
       fself
       ith
       (fun _ _ -> ())
    inherit [named, nameless] Abs.de_bruijn fself
  end
\end{lstlisting}

For the generic part of the terms we reused the \lstinline{eval} transformation, while for abstractions we took the customized one (\lstinline{de_bruijn}); in
any case the final transformation is build via inheritance with no other glue; here \lstinline{ith} is a function, which finds names in an
environment and returns their indices.

It is interesting, that with polymorphic variants is becomes possible to define a transformation with an output type, different from the input
beyond parameterization:

\begin{lstlisting}
   class ['term, 'term2] de_bruijn' ft =
   object
     inherit [string, string list, unit,
              'term, string list, 'term2,
              string list, 'term2, 'term] @abs
     method c_Abs env name term =
       `Abs (ft (name :: env) term) 
   end
     
   @type named = [
   | (string, named) lam
   | (string, named) abs
   ] with eval
                     
   @type nameless = [
   | (int, nameless) lam
   | `Abs of nameless
   ] with eval

   class de_bruijn fself =
   object
     inherit [string, int,
              named, nameless,
              string list,
              nameless] @lam[eval] fself ith fself
      inherit [named, nameless] Abs .de_bruijn' fself 
   end
\end{lstlisting}

Please note the implementation of method \lstinline{c_Abs}~--- now it returns a constructor \lstinline{`Add} with \emph{one}
argument. In short, we defined a transformation into a nameless representation, which completely removes the names in binder
positions.

\subsection{A Custom Plugin}
\label{pluginExample}

Finally we demonstrate the utilization of the plugin system using the example of a fresh custom plugin implementation. For this purpose we
take a well-known \emph{hash-consing} transformation~\cite{HC}. This transformation converts a data structure to its maximally shared
representation, when structurally equal substructures are represented by the same physical object. For example, an expression tree

\begin{lstlisting}
   let t =
     Binop ("+",
       Binop ("-",
         Var "b",
         Binop ("*", Var "b", Var "a")),
       Binop ("*", Var "b", Var "a"))
\end{lstlisting}

can be rewritten into

\begin{lstlisting}
   let t =
     let b  = Var "b" in
     let ba = Binop ("*", b, Var "a") in
     Binop ("+", Binop ("-", b, ba), ba)  
\end{lstlisting}

where equal subexpressions are represented by shared subtrees.

Our plugin for a type ``\lstinline|$\left\{\alpha_i\right\}$ t|'' will provide a hash-consing function ``\lstinline{hc(t)}'' of the type

\begin{lstlisting}
    $\{$ H.t -> $\alpha_i$ -> H.t * $\alpha_i$ $\}$ -> H.t -> $\left\{\alpha_i\right\}$ t -> H.t * $\left\{\alpha_i\right\}$ t
\end{lstlisting}

where ``\lstinline{H.t}''~--- a heterogenious hash table for values of arbitrary types. The interface for the hash table is
as follows:

\begin{lstlisting}
   module H :
   sig
     type t
     val hc : t -> 'a -> t * 'a
   end
\end{lstlisting}

The function ``\lstinline{H.hc}'' takes a hash table and some value and returns a possibly updated table and a structurally equivalent value
of the same type. For now we postpone the description of this module implementation and consider an example of constructor transformation
method:

\begin{lstlisting}   
   method $\inbr{Binop}$ h _ op l r =
     let h, op = hc(string) h op in
     let h, l  = fself h l in
     let h, r  = fself h r in
     H.hc h (Binop (op, l, r))
\end{lstlisting}

The method takes an inherited attribute~---this time a hash table ``\lstinline{h}'',~--- the whole expressions node (which we do not
need in this case, hence underscore), and three arguments of the constructor: ``\lstinline{op}'' of type \lstinline{string}, and
``\lstinline{l}'' and ``\lstinline{r}'' of type \lstinline{expr}. We first hash-cons all three arguments (which gives us a possibly updated
hash table and three hash-consed values of the same types), then we apply the constructor and hash-cons the value again. To hash-cons
the arguments of the constructor we can use the functions provided by the framework~--- for the type \lstinline{string} it is
``\lstinline{hc(string)}''\footnote{Generally speaking, we would need to implement a hash-consing function for each primitive type; in
  our case, however, we could equally use ``\lstinline{H.hc}''.}, and for both subexpressions it is ``\lstinline{fself}''.

As a final component we need to decide on the type parameters for a plugin class for a type ``\lstinline|$\{\alpha_i\}$ t|''. Clearly,
all inherited attribute types has to be ``\lstinline{H.t}'', and synthesized attribute types has to be ``\lstinline{H.t * $a$}'' for the
type of interest ``$a$''. This gives us the following plugin class definition:

\begin{lstlisting}
   class [$\{\alpha_i\}$, $\epsilon$] $\inbr{hc_t}$ $\dots$ =
   object
     inherit [$\{$ H.t, $\alpha_i$, H.t * $\alpha_i$ $\}$, H.t, $\epsilon$, H.t * $\epsilon$] $\inbr{t}$
     $\dots$
   end
\end{lstlisting}

For simplicity we omitted the specification of functional parameters for the class since their types can be trivially
recovered.

Now we need to generate this logic using a plugin.

The infrastructure code for the plugin implementation is shown below:

\begin{lstlisting}
   let trait_name = "hc"
  
   module Make (AstHelpers : GTHELPERS_sig.S) =
     struct
     
       open AstHelpers

       module P = Plugin.Make (AstHelpers)

       class g tdecls =
       object (self : 'self)
         inherit P.with_inherited_attr tdecls as super
         $\ldots$
       end

     end

   let _ =
     Expander.register_plugin trait_name (module Make : Plugin_intf.Plugin)
\end{lstlisting}

To implement a plugin, one needs to implement a functor parameterized by a helper module, which resembles ``\cd{Ast_builder}'' from
\cd{ppxlib} to create \textsc{OCaml} syntax trees. We need to use a functor since we have to provide two implementations for
a plugin~--- for \cd{camlp5} syntax extension as well as for \cd{ppxlib} itself. The main entity in the body of the functor is
a class ``\lstinline{g}'' declaration (``generator''), which for simplicity can be inherited from one of generic classes 
from the framework. In this case we, first, instantiate the generic plugin ``\lstinline{P}'' for ``\lstinline{AstHelpers}'' and
then inherit from the class ``\lstinline{P.with_inherited_attr}'', which means that we are going to implement a plugin
making use of inherited attribute. The class takes a type declaration as a parameter. Finally, we register the functor as a
first-class module in the framework to make it accessible.

Now we show what the methods of the generator class look like. First, we need to specify what are the types of inherited and
synthesized attributes for the plugin:

\begin{lstlisting}
   method main_inh ~loc _tdecl = ht_typ ~loc

   method main_syn ~loc ?in_class tdecl =
     Typ.tuple ~loc
       [ ht_typ ~loc
       ; Typ.use_tdecl tdecl
       ]

   method inh_of_param tdecl _name =
       ht_typ ~loc:(loc_from_caml tdecl.ptype_loc)

   method syn_of_param ~loc s =
     Typ.tuple ~loc
       [ ht_typ ~loc
       ; Typ.var ~loc s
       ]
\end{lstlisting}

where we assume ``\lstinline{ht_typ}'' is defined as

\begin{lstlisting}
   let ht_typ ~loc =
     Typ.of_longident ~loc (Ldot (Lident "H", "t"))
\end{lstlisting}

In other words, we say here that the type of inherited attribute is always ``\lstinline{H.t}'' and the type of a synthesized attribute for
a type of interest ``\lstinline{t}'' is ``\lstinline{H.t * t}''.

The next group of methods specifies the behavior of plugin class type parameters:

\begin{lstlisting}
   method plugin_class_params tdecl =
     let ps =
       List.map tdecl.ptype_params ~f:(fun (t, _) -> typ_arg_of_core_type t)
     in
     ps @
     [ named_type_arg ~loc:(loc_from_caml tdecl.ptype_loc) @@
       Naming.make_extra_param tdecl.ptype_name.txt
     ]

   method prepare_inherit_typ_params_for_alias ~loc tdecl rhs_args =
     List.map rhs_args ~f:Typ.from_caml
\end{lstlisting}

The first method specifies the type parameters for the plugin class itself: this time they are exactly the type parameters of the type declaration plus
the extra parameter ``$\epsilon$''. The second one describes the method of recalculation of type parameters for application of type constructor: when
the type declaration looks like

\begin{lstlisting}
   type $\{\alpha_i\}$ t = $\{a_i\}$ tc
\end{lstlisting}

we need to acquire the implementation of the plugin for ``\lstinline{t}'' from the implementation of the same plugin for ``\lstinline{tc}'', inheriting
from properly instantiated corresponding class. As for our plugin the class is parameterized by the same types as the type, we just keep the parameters.

The last group of methods generate the bodies of constructor transformation. As we support regular constructors with both tuple and record
argument specifications as well as top-level tuples and records, there are four methods, which as a rule share many details of implementation. We show the
skeleton for one of them:

\begin{lstlisting}
method on_tuple_constr ~loc ~is_self_rec ~mutual_decls ~inhe tdecl constr_info ts =
  $\dots$ 
  match ts with
  | [] -> Exp.tuple ~loc [ inhe; c [] ]
  | ts ->
     let res_var_name = sprintf "%s_rez" in
     let argcount = List.length ts in
     let hfhc =
       Exp.of_longident ~loc (Ldot (Lident "H", "hc"))
     in
     List.fold_right
       (List.mapi ~f:(fun n x -> (n, x)) ts)
       ~init:$\dots$
       ~f:(fun (i, (name, typ)) acc ->
            Exp.let_one ~loc
              (Pat.tuple ~loc [ Pat.sprintf ~loc "ht%d" (i+1)
                              ; Pat.sprintf ~loc "%s" @@ res_var_name name])
              (self#app_transformation_expr ~loc
                 (self#do_typ_gen ~loc ~is_self_rec ~mutual_decls tdecl typ)
                 (if i = 0 then inhe else Exp.sprintf ~loc "ht%d" i)
                 (Exp.ident ~loc name)
              )
              acc
          )
  $\dots$
\end{lstlisting}

This implementation makes use of the generic method ``\lstinline{self#app_transformation_expr}'' from the framework, which generates an application of
the transformation in question for a given type.

The final component for the implementation is module ``\lstinline{H}'' itself. The standard functor ``\lstinline{Hashtbl.Make}'' instantiates a
hash table making use of some hash function and equality predicate, supplied by an end user. In a whole, we follow a conventional pattern:
for the hash function we use polymorphic ``\lstinline{Hashtbl.hash}'' and for the equality we use physical equality ``\lstinline{==}''. There are, however, two
subtleties:

\begin{itemize}
\item Since our hash table is heterogenious, we have to utilize unsafe coercion ``\lstinline{Obj.magic}''.
\item Our implementation for equality has to be a little more complex than simple ``\lstinline{==}'': we need to compare the top-level constructors and
  the number of their arguments \emph{structurally}, and only then compare the corresponding arguments by physical equality. Technically this
  may result in hash-consing structurally equal values of \emph{different} types.
\end{itemize}

We rely here on the follow observation: as hash-consing is only consistent with referentially-transparent data structures, we can assume
that structurally equal data structures can be interchangeable regardless their types. The complete implementation for this plugin can be seen in the main project
repository; it occupies 164 LOC, including comments and blank lines.
